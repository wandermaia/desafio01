package main

import (
	"encoding/json"
	"io"
	"log"
	"net/http"
	"time"
)

// Para facilitar a criação do struct com json, pode ser utilizado o site https://mholt.github.io/json-to-go/
// Essa url converte json para struct de forma fácil já com as tags.
type CotacaoDolar struct {
	Usdbrl struct {
		Code       string `json:"code"`
		Codein     string `json:"codein"`
		Name       string `json:"name"`
		High       string `json:"high"`
		Low        string `json:"low"`
		VarBid     string `json:"varBid"`
		PctChange  string `json:"pctChange"`
		Bid        string `json:"bid"`
		Ask        string `json:"ask"`
		Timestamp  string `json:"timestamp"`
		CreateDate string `json:"create_date"`
	} `json:"USDBRL"`
}

// Struct auxiliar que será utilizada para armazenar apenas o Bid e codificar em json
type BidOnly struct {
	Bid string `json:"bid"`
}

func main() {

	// Criação das rotas e do server
	http.HandleFunc("/", HomeHandler)
	http.HandleFunc("/cotacao", BuscaCotacaoHandler)
	log.Println("Servidor iniciado!")
	http.ListenAndServe(":8080", nil)

}

func HomeHandler(w http.ResponseWriter, r *http.Request) {

	if r.URL.Path != "/" {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	w.Write([]byte("Hello World!"))
	ctx := r.Context()
	log.Println("Request Iniciada")
	defer log.Println("Request finalizada")
	select {
	case <-time.After(5 * time.Second):
		// Imprime no comand line stdout
		log.Println("Request home processada com sucesso.")
		// Imprime no browser
		w.Write([]byte("Request home processada com sucesso!"))
	case <-ctx.Done():
		// Imprime no comand line stdout
		log.Println("Request home cancelada pelo cliente.")
	}

}

func BuscaCotacaoHandler(w http.ResponseWriter, r *http.Request) {

	log.Println("Request Iniciada")
	cotacao, err := BuscaCotacao()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Segregando apenas o valor do Bid para o Response
	bidOnly := BidOnly{Bid: cotacao.Usdbrl.Bid}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(bidOnly)
	log.Println("Request Finalizada")

}

// Função que realiza a busca da contação do Dollar
func BuscaCotacao() (*CotacaoDolar, error) {

	resp, error := http.Get("https://economia.awesomeapi.com.br/json/last/USD-BRL")
	if error != nil {
		return nil, error
	}
	defer resp.Body.Close()
	body, error := io.ReadAll(resp.Body)
	if error != nil {
		return nil, error
	}

	var cotacao CotacaoDolar
	error = json.Unmarshal(body, &cotacao)

	if error != nil {
		return nil, error
	}

	return &cotacao, nil

}

/*




O server.go deverá consumir a API contendo o câmbio de Dólar e Real no endereço: https://economia.awesomeapi.com.br/json/last/USD-BRL e em seguida deverá retornar no formato JSON o resultado para o cliente.

Usando o package "context", o server.go deverá registrar no banco de dados **SQLite** cada cotação recebida, sendo que o timeout máximo para chamar a API de cotação do dólar deverá ser de 200ms e o timeout máximo para conseguir persistir os dados no banco deverá ser de 10ms.

>**Observação:**
>
> Todos os contextos deverão retornar erro nos logs caso o tempo de execução seja insuficiente.

O endpoint necessário gerado pelo server.go para este desafio será: /cotacao e a porta a ser utilizada pelo servidor HTTP será a 8080.



Json retornado:


{
  "USDBRL": {
    "code": "USD",
    "codein": "BRL",
    "name": "Dólar Americano/Real Brasileiro",
    "high": "5.0018",
    "low": "4.9818",
    "varBid": "0.0062",
    "pctChange": "0.12",
    "bid": "4.9949",
    "ask": "4.9965",
    "timestamp": "1710536398",
    "create_date": "2024-03-15 17:59:58"
  }
}

Struct criado no site


type AutoGenerated struct {
	Usdbrl struct {
		Code       string `json:"code"`
		Codein     string `json:"codein"`
		Name       string `json:"name"`
		High       string `json:"high"`
		Low        string `json:"low"`
		VarBid     string `json:"varBid"`
		PctChange  string `json:"pctChange"`
		Bid        string `json:"bid"`
		Ask        string `json:"ask"`
		Timestamp  string `json:"timestamp"`
		CreateDate string `json:"create_date"`
	} `json:"USDBRL"`
}

import (
  "gorm.io/driver/sqlite" // Sqlite driver based on CGO
  // "github.com/glebarez/sqlite" // Pure go SQLite driver, checkout https://github.com/glebarez/sqlite for details
  "gorm.io/gorm"
)

// github.com/mattn/go-sqlite3
db, err := gorm.Open(sqlite.Open("gorm.db"), &gorm.Config{})



exemplo
https://medium.com/@wattanai.tha/go-tutorial-series-ep-2-persisting-api-data-with-gorm-c89103cd266b

*/
